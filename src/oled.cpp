// индикатор
#include "oled.h"

#ifndef cbi
#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
#endif
#ifndef sbi
#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
#endif

#ifndef pgm_read_byte
 #define pgm_read_byte(addr) (*(const uint8_t *)(addr))
#endif
#ifndef pgm_read_word
 #define pgm_read_word(addr) (*(const unsigned short *)(addr))
#endif
#ifndef pgm_read_dword
 #define pgm_read_dword(addr) (*(const unsigned long *)(addr))
#endif
#if !defined(__INT_MAX__) || (__INT_MAX__ > 0xFFFF)
 #define pgm_read_pointer(addr) ((void *)pgm_read_dword(addr))
#else
 #define pgm_read_pointer(addr) ((void *)pgm_read_word(addr))
#endif

bool displayPresent;
extern const uint8_t font[];
static uint8_t buffer[SSD_LCDHEIGHT * SSD_LCDWIDTH / 8] = { 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0xc0, 0xc0, 0xc0, 0xc0, 0x60,
0x60, 0x60, 0xc0, 0xc0, 0xc0, 0xc0, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xf0, 0x30,
0x18, 0x0c, 0x0c, 0x06, 0x06, 0x03, 0x03, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x06, 0x06, 0x0c, 0x0c,
0x18, 0x30, 0x30, 0x60, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0xff, 0xff, 0x20,
0x20, 0x20, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x06, 0x0c, 0x38, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x20, 0x20,
0x20, 0x20, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x80, 0xc0, 0x88, 0x80, 0x81, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xff, 0xff, 0x00,
0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x0e, 0x38, 0xe0,
0xc0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xff, 0x80, 0x00,
0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x05, 0x21, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xff, 0xff, 0x00,
0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x81, 0xe1, 0x39, 0x1f, 0x07,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0x60, 0x38, 0x0c, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00, 0x00, 0xf8, 0x10, 0x20,
0x40, 0x20, 0x10, 0xf8, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0xf0, 0x08, 0x08, 0x08,
0x08, 0xf0, 0x00, 0x00, 0x20, 0x10, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x78, 0x80, 0x80, 0x80, 0x80,
0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x1f, 0x1f, 0x30,
0x60, 0x60, 0xc0, 0xc0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0xc0, 0xc0, 0x60, 0x60, 0x30,
0x18, 0x18, 0x0c, 0x06, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00,
0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x04, 0x04,
0x04, 0x03, 0x00, 0x00, 0x04, 0x04, 0x07, 0x04, 0x04, 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x04,
0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x03, 0x03, 0x03, 0x06, 0x06, 0x06, 0x06, 0x0c, 0x0c,
0x0c, 0x06, 0x06, 0x06, 0x06, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
uint8_t cursor_x, cursor_y;
uint8_t textcolor = WHITE;
uint8_t textbgcolor = BLACK;
uint8_t textsize = 1;
char    outStr[60];
GFXfont *gfxFont;

static void I2CStart(){
  TWCR = (1<<TWINT)| (1<<TWSTA)|(1<<TWEN);
  while (!(TWCR & (1<<TWINT)));
}

static void I2CStop(){
  TWCR = (1<<TWINT)| (1<<TWEN)|(1<<TWSTO);
}

static bool I2CSend(char dat){
  TWDR = dat;
  TWCR = (1<<TWINT) | (1<<TWEN);
  while (!(TWCR & (1<<TWINT)));
  if ((TWSR & 0xF8) != TW_MT_SLA_ACK) return false;
  else return true;
}

static void command(char cmd) {
    I2CStart();             //StartI2C();
    displayPresent = I2CSend(i2c_addr);       //send address
    I2CSend(0x00);          //send data incomming
    I2CSend(cmd);       //send command
    I2CStop();              //StopI2C();
}
/*
static void data(char d) {
    I2CStart();             //StartI2C();
    displayPresent = I2CSend(i2c_addr);      //send address
    I2CSend(0x40);          //send data incomming
    I2CSend(d);          //send data
    I2CStop();              //StopI2C();
}
*/
void oledInit() {
  digitalWrite(SDA, 1);
  digitalWrite(SCL, 1);
  cbi(TWSR, TWPS0);
  cbi(TWSR, TWPS1);
  TWBR = ((F_CPU / TWI_FREQ) - 16) / 2;
  TWCR = _BV(TWEN) | _BV(TWEA);
    
  command(0xAE); //display off
	command(0x20); //Set Memory Addressing Mode
	command(0x10); // 00,Horizontal Addressing Mode; 01,Vertical Addressing Mode;
                   // 10,Page Addressing Mode (RESET); 11,Invalid
	command(0xB0); //Set Page Start Address for Page Addressing Mode,0-7
	// или
	command(0xC0); // Mirror vertically
	// или
	//command(0xC8); //Set COM Output Scan Direction
	command(0x00); //---set low column address
	command(0x10); //---set high column address
	command(0x40); //--set start line address - CHECK
	command(0x81); //--set contrast control register - CHECK
	command(0xFF); // 0x00 = min  |  0xFF = max
	// или
	command(0xA0); // Mirror horizontally
	// или
	//command(0xA1); //--set segment re-map 0 to 127 - CHECK
	command(0xA6); //--set normal color
	command(0xA8); //--set multiplex ratio(1 to 64) - CHECK
	command(0x3F); //
	command(0xA4); //0xa4,Output follows RAM content;0xa5,Output ignores RAM content
	command(0xD3); //-set display offset - CHECK
	command(0x00); //-not offset
	command(0xD5); //--set display clock divide ratio/oscillator frequency
	command(0xF0); //--set divide ratio
	command(0xD9); //--set pre-charge period
	command(0x22); //
	command(0xDA); //--set com pins hardware configuration - CHECK
	command(0x12);
	command(0xDB); //--set vcomh
	command(0x20); //0x20,0.77xVcc
	command(0x8D); //--set DC-DC enable
	command(0x14); //
	command(0xAF); //--turn on SSD1306 panel
}


bool OLED_status() {
  return displayPresent;
}

void oledClearDisplay() {
	memset(buffer, 0, (SSD_LCDWIDTH*SSD_LCDHEIGHT/8));
}

void oledDisplay() {
   uint8_t height = SSD_LCDHEIGHT >> 3;
   uint8_t width = SSD_LCDWIDTH >> 3; 
   int p = 0;
   unsigned i, j, k =0;
   
   command(0x00 | 0x0);
   command(0x10 | 0x0);
   command(0x40 | 0x0);
   
   for ( i = 0; i < height; i++) {
		// send a bunch of data in one xmission
        command(SSD_SETPAGESTART + i);//set page address
        command(SSD_SHIFT & 0xf);//set lower column address
        command(0x10 | (SSD_SHIFT >> 4));//set higher column address
        for( j = 0; j < 8; j++){        
			      I2CStart();
            I2CSend(i2c_addr) ;
            I2CSend(0x40) ;
            for ( k = 0; k < width; k++, p++) {
		           I2CSend(buffer[p]);
            }
            I2CStop();
        }
   }
}

void setTextColor(uint8_t color) {
	if (color == WHITE) {
		textcolor = WHITE;
		textbgcolor = BLACK;
	}
	else {
		textcolor = BLACK;
		textbgcolor = WHITE;
	}
}

void oledDrawPixel(uint8_t x, uint8_t y, uint8_t color) {
  if ((x >= SSD_LCDWIDTH) || (y >= SSD_LCDHEIGHT) || (x < 0) || (y < 0))
    return;

  // x is which column
  if (color == WHITE)
    buffer[x+ (y/8)*SSD_LCDWIDTH] |= _BV((y%8));
  else
    buffer[x+ (y/8)*SSD_LCDWIDTH] &= ~_BV((y%8));
}

void oledVLine(uint8_t x, uint8_t y, uint8_t h, uint8_t color) {
  uint8_t i;
  for (i=y; i<y+h; i++) {
    oledDrawPixel(x, i, color);
  }
}

void oledHLine(uint8_t x, uint8_t y, uint8_t w, uint8_t color) {
  uint8_t i;
  for (i=x; i<x+w; i++) {
    oledDrawPixel(i, y, color);
  }
}

void oledDrawRect(uint8_t x, uint8_t y, uint8_t w, uint8_t h, uint8_t color) {
    oledVLine(x, y, h, color);
    oledVLine(x+w, y, h, color);
    oledHLine(x, y, w, color);
    oledHLine(x, y+h, w+1, color);
}

void oledFillRect(uint8_t x, uint8_t y, uint8_t w, uint8_t h, uint8_t color) {
  uint8_t i;
  for (i=x; i<x+w; i++) {
    oledVLine(i, y, h, color);
  }
}

void oledSetTextSize(uint8_t s) {
	if (s > 0 && s < 5) textsize = s;
}

void oledSetCursor(uint8_t x, uint8_t y) {
    cursor_x = x;
    cursor_y = y;
}

void oledSetFont(const GFXfont *f) {
    if(f) {            // Font struct pointer passed in?
        if(!gfxFont) { // And no current font struct?
            // Switching from classic to new font behavior.
            // Move cursor pos down 6 pixels so it's on baseline.
            cursor_y += 6;
        }
    }
    /*else { // NULL passed.  Current font struct defined?
        // Switching from new to classic font behavior.
        // Move cursor pos up 6 pixels so it's at top-left of char.
        cursor_y -= 6;
    }*/
    gfxFont = (GFXfont *)f;
}

void drawChar(uint8_t x, uint8_t y, uint8_t c, uint8_t color, uint8_t bg, uint8_t size) {
    uint8_t i, j;
    if(!gfxFont) { // 'Classic' built-in font
        if((x >= SSD_LCDWIDTH)            || // Clip right
           (y >= SSD_LCDHEIGHT)           || // Clip bottom
           ((x + 6 * size - 1) < 0) || // Clip left
           ((y + 8 * size - 1) < 0))   // Clip top
            return;

        for(i=0; i<5; i++ ) { // Char bitmap = 5 columns
            uint8_t line = pgm_read_byte(&font[c * 5 + i]);
            for(j=0; j<8; j++, line >>= 1) {
                if(line & 1) {
                    if(size == 1)
                        oledDrawPixel(x+i, y+j, color);
                    else
                        oledFillRect(x+i*size, y+j*size, size, size, color);
                } else if(bg != color) {
                    if(size == 1)
                        oledDrawPixel(x+i, y+j, bg);
                    else
                        oledFillRect(x+i*size, y+j*size, size, size, bg);
                }
            }
        }
        if(bg != color) { // If opaque, draw vertical line for last column
            if(size == 1) oledVLine(x+5, y, 8, bg);
            else          oledFillRect(x+5*size, y, size, 8*size, bg);
        }
    } else { // Custom font
        c -= (uint8_t)pgm_read_byte(&gfxFont->first);
        GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&gfxFont->glyph))[c]);
        uint8_t  *bitmap = (uint8_t *)pgm_read_pointer(&gfxFont->bitmap);

        uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
        uint8_t  w  = pgm_read_byte(&glyph->width),
                 h  = pgm_read_byte(&glyph->height);
        int8_t   xo = pgm_read_byte(&glyph->xOffset),
                 yo = pgm_read_byte(&glyph->yOffset);
        uint8_t  xx, yy, bits = 0, bit = 0;
        int16_t  xo16 = 0, yo16 = 0;

        if(size > 1) {
            xo16 = xo;
            yo16 = yo;
        }
        for(yy=0; yy<h; yy++) {
            for(xx=0; xx<w; xx++) {
                if(!(bit++ & 7)) {
                    bits = pgm_read_byte(&bitmap[bo++]);
                }
                if(bits & 0x80) {
                    if(size == 1) {
                        oledDrawPixel(x+xo+xx, y+yo+yy, color);
                    } else {
                        oledFillRect(x+(xo16+xx)*size, y+(yo16+yy)*size,
                          size, size, color);
                    }
                }
                bits <<= 1;
            }
        }
    }
}

void charWrite(uint8_t c) {
    if(!gfxFont) { // 'Classic' built-in font
        if(c == '\n') {                        // Newline?
            cursor_x  = 0;                     // Reset x to zero,
            cursor_y += textsize * 8;          // advance y one line
        } else if(c != '\r') {                 // Ignore carriage returns
            if((cursor_x + textsize * 6) > SSD_LCDWIDTH) { // Off right?
                cursor_x  = 0;                 // Reset x to zero,
                cursor_y += textsize * 8;      // advance y one line
            }
            drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize);
            cursor_x += textsize * 6;          // Advance x one char
        }
    } else { // Custom font
        if(c == '\n') {
            cursor_x  = 0;
            cursor_y += (int16_t)textsize * (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
        } else if(c != '\r') {
            uint8_t first = pgm_read_byte(&gfxFont->first);
            if((c >= first) && (c <= (uint8_t)pgm_read_byte(&gfxFont->last))) {
                GFXglyph *glyph = &(((GFXglyph *)pgm_read_pointer(
                  &gfxFont->glyph))[c - first]);
                uint8_t   w     = pgm_read_byte(&glyph->width),
                          h     = pgm_read_byte(&glyph->height);
                if((w > 0) && (h > 0)) { // Is there an associated bitmap?
                    int16_t xo = (int8_t)pgm_read_byte(&glyph->xOffset);
                    if((cursor_x + textsize * (xo + w)) > SSD_LCDWIDTH) {
                        cursor_x  = 0;
                        cursor_y += (int16_t)textsize *
                          (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
                    }
                    drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize);
                }
                cursor_x += (uint8_t)pgm_read_byte(&glyph->xAdvance) * (int16_t)textsize;
            }
        }
    }
}

void oledPrint(char* str) {
	// поиск русских символов
	int i = 0, j = 0;
	char strOut[60];
	uint8_t n;

	while (str[i] != '\0') {
	    n = str[i];
      i++;

	    if (n >= 0xC0) {
	      switch (n) {
			  case 0xD0: {
				n = str[i]; i++;
				if (n == 0x81) { n = 0xA8; break; }
				if (n >= 0x90 && n <= 0xBF) n = n + 0x30;
				break;
			  }
			  case 0xD1: {
				n = str[i]; i++;
				if (n == 0x91) { n = 0xB8; break; }
				if (n >= 0x80 && n <= 0x8F) n = n + 0x70;
				break;
			  }
	      }
	    }
	    strOut[j] = n; j++;//m[0] = n; strOut[j] = m[0]; j++; strOut[j] = m[1]; j++;
	}
	strOut[j] = '\0';

	// собственно вывод
    short pos = 0;
    char character = strOut[pos++];

    while(character != '\0') {
        charWrite(character);
        character = strOut[pos++];
    }
}

void oledMainScreen() {
  oledSetFont(NULL);
  oledSetTextSize(1);
  oledSetCursor(0, 0);
  sprintf(outStr, "Is Ready: %s", (isReady) ? "Yes" : "No");
  oledPrint(outStr);
  oledSetCursor(0, 20);
  sprintf(outStr, "Impuls: %d ms", impulsTime);
  oledPrint(outStr);
}

/*
// Вывод экранов
void startScreen() {
  oledSetFont(NULL);
  oledSetCursor(94, 3);
  sprintf(outStr, "%d%s", (uint16_t)(frecuence), " Гц");
  oledPrint(outStr);
}
// Основной экран стабилизации мощности с управлением по UART (0)
void powerStabScreen() {
	oledSetFont(NULL);
	oledSetTextSize(1);
	
  // напряжение
	oledSetCursor(8, 0);
	sprintf(outStr, "U: %d%s%d", Voltage, "/", VoltageOn);
	oledPrint(outStr);

  // установленный %
  oledSetCursor(92, 0);
  sprintf(outStr, "%d%s", triacPercentIn, "%");
  oledPrint(outStr);
    
	// ток
	oledSetCursor(8, 16);
  sprintf(outStr, "I: %d.%02d", (uint16_t)(CurrentOut), (uint16_t)(CurrentOut * 100) % 100);
  oledPrint(outStr);
	
    // заданная мощность
	oledSetCursor(74, 16);
	sprintf(outStr, "P: %d%s", userPowerSet, "Вт");
	oledPrint(outStr);



	// мощность на нагрузке
  PowerOut[4] = PowerOut[3];
  PowerOut[3] = PowerOut[2];
  PowerOut[2] = PowerOut[1];
  PowerOut[1] = Power;
  // вычислим ближайший к текущему значению результат
  uint16_t dt1 = abs(PowerOut[1] - userPowerSet);
  uint16_t dt2 = abs(PowerOut[2] - userPowerSet);
  uint16_t dt3 = abs(PowerOut[3] - userPowerSet);
  uint16_t dt4 = abs(PowerOut[4] - userPowerSet);
  if (dt1 <= dt2 && dt1 <= dt3 && dt1 <= dt4) PowerOut[0] = PowerOut[1];
  else if (dt2 <= dt1 && dt2 <= dt3 && dt2 <= dt4) PowerOut[0] = PowerOut[2];
  else if (dt3 <= dt1 && dt3 <= dt2 && dt3 <= dt4) PowerOut[0] = PowerOut[3];
  else if (dt4 <= dt1 && dt4 <= dt2 && dt4 <= dt3) PowerOut[0] = PowerOut[4];

  if (PowerOut[0] < 10) oledSetCursor(40, 52);
	else if (PowerOut[0] < 100) oledSetCursor(30, 52);
	else if (PowerOut[0] < 1000) oledSetCursor(20, 52);
  else oledSetCursor(10, 52);
	oledSetFont(&FreeSerifBold18pt7b);

  
  if (PowerOut[0] >= 10) sprintf(outStr, "%d%s", PowerOut[0], " w");
  else sprintf(outStr, "%s", "0 w");
	
	oledPrint(outStr);
}

// Установка мощности ТЭНа
void powerSetScreen() {
	oledSetFont(NULL);
	oledSetTextSize(1);
	oledSetCursor(18, 10);
	//oledPrint("Мощность ТЭНа Вт");
  oledPrint(const_cast<char *>("Мощность ТЭНа Вт"));


	if (powerMax < 1000) oledSetCursor(38, 46);
	else oledSetCursor(26, 46);

	oledSetFont(&FreeSerifBold18pt7b);
	sprintf(outStr, "%d", powerMax);
	oledPrint(outStr);
}
*/